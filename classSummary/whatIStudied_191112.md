# What I studied today.
Date : 2019-11-12


# JAVA
## 객체지향 개념 복습
* 매개값, 인수, argument
* 매개변수, 인자, parameter
## MemberCall 예제
* 스태틱멤버와 인스턴스멤버 사용 시 주의해야할 것 
    1. 인스턴스 멤버는 명시적 초기화 시 스태틱 멤버의 값을 초기값으로 사용 **가능**
    2. 스태틱 멤버는 명시적 초기화 시 인스턴스 멤버의 값을 초기값으로 사용 *불가*
        * 객체를 생성하면 가능
    3. 스태틱메소드에서 인스턴스 멤버필드 접근 *불가능*
        * 메소드 내에서 객체를 생성하면 해당(새로 생성한) 객체의 인스턴스멤버는 사용 **가능**.
    4. 인스턴스메소드에서는 스태틱멤버필드와 인스턴스멤버필드 둘다 접근 **가능**
    5. 스태틱멤버메소드에서는 인스턴스멤버메소드 접근 *불가능*
    6. 인스턴스멤버메소드에서는 스태틱멤버 메소드 접근 **가능**
## 메소드오버로딩
* 장점
    * 단지이름만으로 구별된다면 같은 기능의 함수도각기 다른 이름을 가져야함
    * 같은 기능의 메서드들의 이름을 같이함
## 가변인자
* 매개변수의 개수가 동적으로 지정됨
1. 내부적으로는 1차원 배열과 동일하게 동작한다.
2. 가변인자는 매개변수 중 제일 마지막에 위치해야한다.
    * 오류 예시
    > The variable argument type String of the method printStr4 must be the last parameter
## 초기화 방법
* 명시적 초기화 
* 초기화 블럭
    * 클래스 초기화 블럭
    * 인스턴스 초기화 블럭
* 생성자
### 초기화 블럭
* 초기화 블럭 종류
    * 클래스(정적) 초기화 블럭
        * 클래스변수의 복잡한 초기화에 사용
    * 인스턴스 초기화 블럭
        * 인스턴스변수의 복잡한 초기화에 사용
* 초기화 블록이 2개이상 있더라도 차례로 실행된다. 
* 초기화 블록을 사용하는 이유
    * 수식을 이용해 초기화 할 경우.
    * 단순 대입외에 조건문,반복문 등의 복잡한 연산을 하기 위함.
* 초기화 블럭의 실행 시점 알아 둘 것
    ```java
    class InitializationBlock {
        // 0. 가장 먼저 초기화 됨
        static int num = 10;
        // 1. 인스턴스 생성 전에 실행 됨.
        static {
            num = 20;
            System.out.println("클래스 초기화 블럭 실행");
        }
        // 2. 인스턴스 생성하면 제일 먼저 실행됨
        {
            System.out.println("인스턴스 초기화 블럭 실행");
        }
        {
            System.out.println("인스턴스 초기화 블럭 실행 두 번째");
        }
        // 3. 인스턴스 초기화 블록 실행 후 실행됨
        public InitializationBlock() {     
            System.out.println("생성자 실행");
        }

        public static void main(String args[]) {
            System.out.println("InitializationBlock ib = new InitializationBlock(); ");
            InitializationBlock ib = new InitializationBlock();

            System.out.println("InitializationBlock ib2 = new InitializationBlock(); ");
            InitializationBlock ib2 = new InitializationBlock();
        }
    }
    ```
* 실행 결과
    * ```
        클래스 초기화 블럭 실행
        InitializationBlock ib = new InitializationBlock(); 
        인스턴스 초기화 블럭 실행
        인스턴스 초기화 블럭 실행 두 번째
        생성자 실행
        InitializationBlock ib2 = new InitializationBlock(); 
        인스턴스 초기화 블럭 실행
        인스턴스 초기화 블럭 실행 두 번째
        생성자 실행    
        ```
* 인스턴스 초기화 블록 이후에 생성자가 실행되는 이유는 
    * 상속 시 초기화를 재정의 할 수 있게 하기 위함인가?
## 클래스 구조
```java
[public] class 클래스명{
    // 1. 멤버필드
    // 1.1 정적 맴버 필드   
    [public | private | protected] static 타입명 변수명;
    // 1.2 인스턴스 맴버 필드   
    [public | private | protected]  타입명 변수명;

    // 2. 초기화 블럭
    // 2.1 정적 초기화 블럭
    static { }
    // 2.2 인스턴스 초기화 블럭
    { }

    // 3. 생성자 메소드
    [public | private | protected] 클래스명() {

    }

    // 4. 멤버 메소드
    // 4.1 정적 멤버 메소드
    [public | private | protected] static 리턴타입명 메소드명(매개변수타입 매개변수) {
        return 리턴값;
    }
    // 4.2 인스턴스 멤버 메소드
    [public | private | protected] 리턴타입명 메소드명(매개변수타입 매개변수) {
        return 리턴값;
    }
    // 5. 멤버 클래스 (내부 클래스 inner class)
    // 5.1 정적 멤버 크래스
    // 5.2 인스턴스 멤버 클래스
}
}
```

## 객체 용어 정리(최신)
1. 객체란
    1. 현실세계의 객체
        * 물리적으로 존재하는 것(사람,자동차 등)
        * 추상적으로 존재하는 것(회사, 날짜, 도덕, 관념, 상상 등)
    2. 인스턴스와 객체
        * 현실세계의 객체를 추상화(속성, 행위)하여  
          만든 클래스(멤버필드,멤버메소드)를  
          인스턴스화(new, 힙 메모리에 생성)한 객체(인스턴스)
        * 하나하나를 얘기할 때는 인스턴스 뭉뚱그려 이야기할 때는 Object
    3. 클래스
        * 자바에서 객체지향 프로그래밍의 최소 단위
        * 가상세계의 객체를 만드는 설계도
        * 멤버필드만으로도 구성될 수 있다.
        * 멤버메소드만으로도 구성될 수 있다.
    4. 객체지향 프로그래밍
        * 부품 객체(클래스)를 만들고 이것들을 하나씩 조합해  
            완성된 프로그래밍으로 만드는 기법
2. 생성자 메소드(constructor)
    * 용도 : 
        * 객체를 초기화 하기위해 사용되는 메소드
    * 특징 : 
        * 생성자 이름은 클래스 이름과 동일
        * 생성자 이름앞에 리턴타입이 없다.
        * 디폴트 생성자(매개변수가 없고 받이에 실행문이 없는 생성자)는
        프로그래머가 구현하지 않더라도 컴파일러가 자동 추가해준다.
            * 프로그래머가 만든 생성자가 하나라도 존재하면 컴파일러는 디폴트 생성자를 만들지 않는다.
3. 오버로딩(overloading)
    * 종류
        * 생성자 오버로딩, 메소드 오버로딩
    * 의미
        * 동일한 이름을 가진 생성자나 메소드를 여러개 선언이 가능하다. 
        단, 매개변수(갯수, 타입)는 달라야한다.
4. this
    * 의미
        * 객체 자기 자신
    * 용도 
        * 멤버필드와 생성자 매개변수, 멤버 메소드의 매개변수가 동일할 때 멤버필드와 구분하기 위해 사용
5. this()
    * 의미
        * 객체 자기 자신의 생성자를 호출
    * 용도
        * 이미 존재하는 생성자를 재사용(코드의 중복 방지)
    * super()
        * 부모클래스의 생성자 호출
6. get메소드, set메소드
    * private로 선언된 멤버 필드의 값을 읽기, 쓰기 용도로 사용됨.
    멤버필드를 캡슐화 하는 방법으로 사용됨.
    유효성 체크로직이 포함될 수 있음
7. Object.toString()
    * 현 객체의 상태를 문자열로 표현하는 용도로 사용된다.
    (패키지가 포함된 클래스명+@+주소값(16진수))
    * 자식클래스에서 재정의해서 객체상태를 표현하는데 사용딘다.
    (주로 멤버필드의 현재값 확인용도)
8. static
    * 클래스에 고정된 필드와 메소드(정적필드, 정적메소드)
    * 정적멤버는 힙메모리에 생성된 객체 내부에 존재하지 않고 메소드 메모리 영역에 존재한다.
    * 정적멤버는 객체를 생성하지 않고 클래스이름으로 바로 접근해 사용가능.
        * 클래스를 통해서 접근하는 것이 좋음
        * 객체를 통해서 접근할 경우 Warning이 뜸
        > The static field Calculator.maker should be accessed in a static way
    * 정적멤버는 모든 인스턴스에서 공유할 수 있는 멤버가 된다.
9. 클래스 멤버
    * 멤버필드
        * 인스턴스 필드
        * 정적 필드(static 키워드가 앞에 붙는다)
    * 멤버메소드
        * 인스턴스 메소드
        * 정적 메소드(static 리턴타입 앞에 붙는다)
10. 초기화블럭
    1. 정적초기화블럭 `static { }`
        * 실행시점 
            * `main`메소드 실행전
        * 용도
            * 수식을 통한 멤버 필드 초기화
    2. 인스턴스 초기화 블럭 `{ }`
        * 실행시점 : 
            * 생성자 호출되어 생성자 몸체 실행문이 실행되기 전
        * 용도
            * 수식을 통한 인스턴스 멤버필드 초기화
# Database
## 조인 용어 정리
1. 가티션곱
2. 내부조인(inner join)
3. 외부조인
    1. left outer join
    2. right outer join
    3. full outer join
4. null의 의미

## 조인 방식
* from 절에 조인을 지정하는 방식
* where 절에 조인을 지정하는 방식
    * `(+)`의 위치를 잘 기억할 것
    * 부족한 쪽에 붙음

## 부속 질의
* 부속질의(subquery)
    * select 문의 where 절에 또 달느 테이블 결과를 이용하기 위해 다시 select문을 괄호로 묶은 것
    * 질의가 중첩되어 있다는 의미에서 중첩질의(nested query)라고도 함
* 상관 부속질의(correlated cubquery) 
    * 상위 부속질의의 튜플을 이용하여 하위 부속질의를 계산
    * 상위 부속질의와 하위 부속질의가 독립적이지 않고 서로 관련을 맺고 있음
    * 질의 3-31 이해할 것...
* 투플변수(tuple variable)
    * 테이블의 별칭을 붙여 사용하는 것